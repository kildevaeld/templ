(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require, exports, module);
  } else {
    root.templ = factory();
  }
}(this, function (require, exports, module) {
  var parser;
  (function (parser_1) {
    parser_1.parser = (function () {
/*
         * Generated by PEG.js 0.8.0.
         *
         * http://pegjs.majda.cz/
         */

      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }

      function SyntaxError(message, expected, found, offset, line, column) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.offset = offset;
        this.line = line;
        this.column = column;
        this.name = "SyntaxError";
      }
      peg$subclass(SyntaxError, Error);

      function parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {},
            peg$FAILED = {},
            peg$startRuleIndices = {
            Start: 0
            },
            peg$startRuleIndex = 0,
            peg$consts = [

          function (children) {
            return children;
          },
          peg$FAILED, "<!DOCTYPE",
          {
            type: "literal",
            value: "<!DOCTYPE",
            description: "\"<!DOCTYPE\""
          }, [], /^[^>]/,
          {
            type: "class",
            value: "[^>]",
            description: "[^>]"
          }, ">",
          {
            type: "literal",
            value: ">",
            description: "\">\""
          }, function (info) {
            return ["doctype", info.join("")];
          }, function (children) {
            return trimTextExpressions(children);
          }, "<!--",
          {
            type: "literal",
            value: "<!--",
            description: "\"<!--\""
          },
          void 0, "-->",
          {
            type: "literal",
            value: "-->",
            description: "\"-->\""
          }, function (v) {
            return v;
          }, function (value) {
            return ["comment", escapeString(trimEnds(value.join("")))];
          }, "<script",
          {
            type: "literal",
            value: "<script",
            description: "\"<script\""
          }, "</script>",
          {
            type: "literal",
            value: "</script>",
            description: "\"</script>\""
          }, function (attributes, content) {
            return ["element", "script", attributes, [
              ["text", escapeString(content.join(""))]
            ]];
          }, function () {
            return text();
          }, "<",
          {
            type: "literal",
            value: "<",
            description: "\"<\""
          }, "area",
          {
            type: "literal",
            value: "area",
            description: "\"area\""
          }, "base",
          {
            type: "literal",
            value: "base",
            description: "\"base\""
          }, "br",
          {
            type: "literal",
            value: "br",
            description: "\"br\""
          }, "col",
          {
            type: "literal",
            value: "col",
            description: "\"col\""
          }, "command",
          {
            type: "literal",
            value: "command",
            description: "\"command\""
          }, "embed",
          {
            type: "literal",
            value: "embed",
            description: "\"embed\""
          }, "hr",
          {
            type: "literal",
            value: "hr",
            description: "\"hr\""
          }, "img",
          {
            type: "literal",
            value: "img",
            description: "\"img\""
          }, "input",
          {
            type: "literal",
            value: "input",
            description: "\"input\""
          }, "keygen",
          {
            type: "literal",
            value: "keygen",
            description: "\"keygen\""
          }, "link",
          {
            type: "literal",
            value: "link",
            description: "\"link\""
          }, "meta",
          {
            type: "literal",
            value: "meta",
            description: "\"meta\""
          }, "param",
          {
            type: "literal",
            value: "param",
            description: "\"param\""
          }, "source",
          {
            type: "literal",
            value: "source",
            description: "\"source\""
          }, "track",
          {
            type: "literal",
            value: "track",
            description: "\"track\""
          }, "wbr",
          {
            type: "literal",
            value: "wbr",
            description: "\"wbr\""
          },
          null, "/>",
          {
            type: "literal",
            value: "/>",
            description: "\"/>\""
          }, function (nodeName, attributes, endTag) {
            if (endTag && nodeName != endTag.name) {
              expected("</" + nodeName + ">");
            }
            return ["element", nodeName, attributes, []];
          }, "</",
          {
            type: "literal",
            value: "</",
            description: "\"</\""
          }, function (name) {
            return {
              name: name
            };
          }, function (startTag, children, endTag) {
            if (startTag.name != endTag.name) {
              expected("</" + startTag.name + ">");
            }
            return ["element", startTag.name, startTag.attributes, children];
          }, function (value) {
            return ["text", escapeString(trimNewLineChars(value.join("")))];
          }, "{{",
          {
            type: "literal",
            value: "{{",
            description: "\"{{\""
          }, function (info) {
            return info;
          }, function (info) {
            return ["element", info.name, info.attributes, []];
          }, function (name, attrs) {
            return {
              name: name,
              attributes: attrs
            };
          }, function (attributes) {
            return attributes;
          }, /^[a-zA-Z0-9:_.\-]/,
          {
            type: "class",
            value: "[a-zA-Z0-9:_.\\-]",
            description: "[a-zA-Z0-9:_.\\-]"
          }, function (word) {
            return word.join("");
          }, "=",
          {
            type: "literal",
            value: "=",
            description: "\"=\""
          }, function (name, values) {
            return ["attribute", name, values];
          }, function (name, property) {
            return ["property", name, property];
          }, function (name) {
            return ['attribute', name, []];
          }, "\"",
          {
            type: "literal",
            value: "\"",
            description: "\"\\\"\""
          }, /^[^"]/,
          {
            type: "class",
            value: "[^\"]",
            description: "[^\"]"
          }, function () {
            return ["string", text()];
          }, function (values) {
            return attrValues(values);
          }, "'",
          {
            type: "literal",
            value: "'",
            description: "\"'\""
          }, /^[^']/,
          {
            type: "class",
            value: "[^']",
            description: "[^']"
          }, "}}",
          {
            type: "literal",
            value: "}}",
            description: "\"}}\""
          }, function (value) {
            return ["script", value];
          }, function (script) {
            return ["block", script[1]];
          }, "?",
          {
            type: "literal",
            value: "?",
            description: "\"?\""
          }, ":",
          {
            type: "literal",
            value: ":",
            description: "\":\""
          }, function (condition, left, right) {
            return ["condition", condition, left, right];
          }, "(",
          {
            type: "literal",
            value: "(",
            description: "\"(\""
          }, ")",
          {
            type: "literal",
            value: ")",
            description: "\")\""
          }, function (params) {
            return params;
          }, "()",
          {
            type: "literal",
            value: "()",
            description: "\"()\""
          }, function () {
            return [];
          }, ",",
          {
            type: "literal",
            value: ",",
            description: "\",\""
          }, function (param1, rest) {
            return [param1].concat(rest.map(function (v) {
              return v[1];
            }));
          }, function (left, right) {
            return ["assign", left, right];
          }, "&&",
          {
            type: "literal",
            value: "&&",
            description: "\"&&\""
          }, "||",
          {
            type: "literal",
            value: "||",
            description: "\"||\""
          }, "===",
          {
            type: "literal",
            value: "===",
            description: "\"===\""
          }, "==",
          {
            type: "literal",
            value: "==",
            description: "\"==\""
          }, "!==",
          {
            type: "literal",
            value: "!==",
            description: "\"!==\""
          }, "!=",
          {
            type: "literal",
            value: "!=",
            description: "\"!=\""
          }, ">==",
          {
            type: "literal",
            value: ">==",
            description: "\">==\""
          }, ">=",
          {
            type: "literal",
            value: ">=",
            description: "\">=\""
          }, "<==",
          {
            type: "literal",
            value: "<==",
            description: "\"<==\""
          }, "<=",
          {
            type: "literal",
            value: "<=",
            description: "\"<=\""
          }, "+",
          {
            type: "literal",
            value: "+",
            description: "\"+\""
          }, "-",
          {
            type: "literal",
            value: "-",
            description: "\"-\""
          }, "%",
          {
            type: "literal",
            value: "%",
            description: "\"%\""
          }, "*",
          {
            type: "literal",
            value: "*",
            description: "\"*\""
          }, "/",
          {
            type: "literal",
            value: "/",
            description: "\"/\""
          }, function (left, operator, right) {
            return ["operator", operator, left, right];
          }, function (value) {
            return value;
          }, function (expression, modifiers) {
            for (var i = 0, n = modifiers.length; i < n; i++) {
              expression = ["modifier", modifiers[i].name, [expression].concat(modifiers[i].parameters)];
            }
            return expression;
          }, "|",
          {
            type: "literal",
            value: "|",
            description: "\"|\""
          }, function (name, parameters) {
            return {
              name: name,
              parameters: parameters || []
            };
          }, function (context) {
            return context;
          }, "!",
          {
            type: "literal",
            value: "!",
            description: "\"!\""
          }, function (not, value) {
            return ["not", value];
          }, function (not, value) {
            return ["negative", value];
          }, /^[0-9]/,
          {
            type: "class",
            value: "[0-9]",
            description: "[0-9]"
          }, function (value) {
            return ["literal", parseFloat(text())];
          }, ".",
          {
            type: "literal",
            value: ".",
            description: "\".\""
          }, function (group) {
            return ["group", group];
          }, function (expression) {
            return expression;
          }, "true",
          {
            type: "literal",
            value: "true",
            description: "\"true\""
          }, "false",
          {
            type: "literal",
            value: "false",
            description: "\"false\""
          }, function (value) {
            return ["literal", value === "true"];
          }, "undefined",
          {
            type: "literal",
            value: "undefined",
            description: "\"undefined\""
          }, function () {
            return ["literal", void 0];
          }, "NaN",
          {
            type: "literal",
            value: "NaN",
            description: "\"NaN\""
          }, function () {
            return ["literal", NaN];
          }, "Infinity",
          {
            type: "literal",
            value: "Infinity",
            description: "\"Infinity\""
          }, function () {
            return ["literal", Infinity];
          }, "null",
          {
            type: "literal",
            value: "null",
            description: "\"null\""
          }, "NULL",
          {
            type: "literal",
            value: "NULL",
            description: "\"NULL\""
          }, function () {
            return ["literal", null];
          }, function (reference, parameters) {
            return ["call", reference, parameters];
          }, "^",
          {
            type: "literal",
            value: "^",
            description: "\"^\""
          }, "~>",
          {
            type: "literal",
            value: "~>",
            description: "\"~>\""
          }, "<~>",
          {
            type: "literal",
            value: "<~>",
            description: "\"<~>\""
          }, "~",
          {
            type: "literal",
            value: "~",
            description: "\"~\""
          }, "<~",
          {
            type: "literal",
            value: "<~",
            description: "\"<~\""
          }, function (bindingType, reference, path) {
            return ["reference", [reference].concat(path), bindingType];
          }, function (name) {
            return name;
          }, "[",
          {
            type: "literal",
            value: "[",
            description: "\"[\""
          }, "]",
          {
            type: "literal",
            value: "]",
            description: "\"]\""
          }, function (key) {
            return key;
          }, /^[a-zA-Z_$0-9]/,
          {
            type: "class",
            value: "[a-zA-Z_$0-9]",
            description: "[a-zA-Z_$0-9]"
          }, function (name) {
            return text();
          }, "{",
          {
            type: "literal",
            value: "{",
            description: "\"{\""
          }, "}",
          {
            type: "literal",
            value: "}",
            description: "\"}\""
          }, function (values) {
            return ["hash", values];
          }, function (values) {
            var s = {};
            for (var i = 0, n = values.length; i < n; i++) {
              s[values[i].key] = values[i].value;
            }
            return s;
          }, function (firstValue, additionalValues) {
            return [
            firstValue].concat(additionalValues.length ? additionalValues[0][1] : []);
          }, function (key, value) {
            return {
              key: key,
              value: value
            };
          }, function (key) {
            return key[1];
          }, function (key) {
            return key;
          },
          {
            type: "other",
            description: "string"
          }, function (chars) {
            return ["string", chars.join("")];
          }, "\\",
          {
            type: "literal",
            value: "\\",
            description: "\"\\\\\""
          }, function () {
            return text();
          }, "\\\"",
          {
            type: "literal",
            value: "\\\"",
            description: "\"\\\\\\\"\""
          }, "\\'",
          {
            type: "literal",
            value: "\\'",
            description: "\"\\\\'\""
          },
          {
            type: "any",
            description: "any character"
          }, /^[a-zA-Z]/,
          {
            type: "class",
            value: "[a-zA-Z]",
            description: "[a-zA-Z]"
          }, function (chars) {
            return chars.join("");
          }, /^[ \n\r\t]/,
          {
            type: "class",
            value: "[ \\n\\r\\t]",
            description: "[ \\n\\r\\t]"
          }],
            peg$bytecode = [
          peg$decode("7!"), peg$decode("!7#+' 4!6 !! %"), peg$decode("!.\"\"\"2\"3#+q$7Z+g% $0%\"\"1!3&+,$,)&0%\"\"1!3&\"\"\" !+B%7Z+8%.'\"\"2'3(+(%4%6)%!\"%$%# !$$# !$## !$\"# !\"# !"), peg$decode("! $7'*; \"7%*5 \"7)*/ \"7$*) \"7**# \"75,A&7'*; \"7%*5 \"7)*/ \"7$*) \"7**# \"75\"+' 4!6*!! %"), peg$decode("!7Z+\xC7$.+\"\"2+3,+\xB7% $!!8..\"\"2.3/9*$$\"\" -\"# !+2$7X+(%4\"60\"! %$\"# !\"# !+T$,Q&!!8..\"\"2.3/9*$$\"\" -\"# !+2$7X+(%4\"60\"! %$\"# !\"# !\"\"\" !+B%..\"\"2.3/+2%7Z+(%4%61%!\"%$%# !$$# !$## !$\"# !\"# !*# \"7\""), peg$decode("!7Z+\x86$.2\"\"2233+v%7/+l%.'\"\"2'3(+\\% $7&+&$,#&7&\"\"\" !+C%.4\"\"2435+3%7Z+)%4'66'\"$\"%$'# !$&# !$%# !$$# !$## !$\"# !\"# !"), peg$decode("!!8.4\"\"24359*$$\"\" -\"# !+1$7X+'%4\"67\" %$\"# !\"# !"), peg$decode("!.8\"\"2839+\u012A$.:\"\"2:3;*\xD1 \".<\"\"2<3=*\xC5 \".>\"\"2>3?*\xB9 \".@\"\"2@3A*\xAD \".B\"\"2B3C*\xA1 \".D\"\"2D3E*\x95 \".F\"\"2F3G*\x89 \".H\"\"2H3I*} \".J\"\"2J3K*q \".L\"\"2L3M*e \".N\"\"2N3O*Y \".P\"\"2P3Q*M \".R\"\"2R3S*A \".T\"\"2T3U*5 \".V\"\"2V3W*) \".X\"\"2X3Y+f%7/+\\%.'\"\"2'3(*) \".[\"\"2[3\\*# \" Z+:%7(*# \" Z+*%4%6]%##\" %$%# !$$# !$## !$\"# !\"# !"), peg$decode("!7Z+\u010C$.^\"\"2^3_+\xFC%.:\"\"2:3;*\xD1 \".<\"\"2<3=*\xC5 \".>\"\"2>3?*\xB9 \".@\"\"2@3A*\xAD \".B\"\"2B3C*\xA1 \".D\"\"2D3E*\x95 \".F\"\"2F3G*\x89 \".H\"\"2H3I*} \".J\"\"2J3K*q \".L\"\"2L3M*e \".N\"\"2N3O*Y \".P\"\"2P3Q*M \".R\"\"2R3S*A \".T\"\"2T3U*5 \".V\"\"2V3W*) \".X\"\"2X3Y+8%.'\"\"2'3(+(%4$6`$!!%$$# !$## !$\"# !\"# !"), peg$decode("!7,+>$7#+4%70+*%4#6a##\"! %$## !$\"# !\"# !*# \"7-"), peg$decode("! $7++&$,#&7+\"\"\" !+' 4!6b!! %"), peg$decode("!!8.8\"\"2839*) \".c\"\"2c3d9*$$\"\" -\"# !+1$7X+'%4\"67\" %$\"# !\"# !"), peg$decode("!7Z+\\$.8\"\"2839+L%7.+B%.'\"\"2'3(+2%7Z+(%4%6e%!\"%$%# !$$# !$## !$\"# !\"# !"), peg$decode("!7Z+\\$.8\"\"2839+L%7.+B%.[\"\"2[3\\+2%7Z+(%4%6f%!\"%$%# !$$# !$## !$\"# !\"# !"), peg$decode("!71+3$7/+)%4\"6g\"\"! %$\"# !\"# !"), peg$decode("!7Z+D$ $72,#&72\"+2%7Z+(%4#6h#!!%$## !$\"# !\"# !"), peg$decode("!.^\"\"2^3_+B$71+8%.'\"\"2'3(+(%4#6`#!!%$## !$\"# !\"# !"), peg$decode("!7Z+M$ $0i\"\"1!3j+,$,)&0i\"\"1!3j\"\"\" !+(%4\"6k\"! %$\"# !\"# !"), peg$decode("!71+W$7Z+M%.l\"\"2l3m+=%7Z+3%73+)%4%6n%\"$ %$%# !$$# !$## !$\"# !\"# !*t \"!71+W$7Z+M%.l\"\"2l3m+=%7Z+3%74+)%4%6o%\"$ %$%# !$$# !$## !$\"# !\"# !*/ \"!71+' 4!6p!! %"), peg$decode("!.q\"\"2q3r+\u0146$ $74*\x9B \"! $!!8.c\"\"2c3d9*$$\"\" -\"# !+3$0s\"\"1!3t+#%'\"%$\"# !\"# !+U$,R&!!8.c\"\"2c3d9*$$\"\" -\"# !+3$0s\"\"1!3t+#%'\"%$\"# !\"# !\"\"\" !+& 4!6u! %,\xA1&74*\x9B \"! $!!8.c\"\"2c3d9*$$\"\" -\"# !+3$0s\"\"1!3t+#%'\"%$\"# !\"# !+U$,R&!!8.c\"\"2c3d9*$$\"\" -\"# !+3$0s\"\"1!3t+#%'\"%$\"# !\"# !\"\"\" !+& 4!6u! %\"+8%.q\"\"2q3r+(%4#6v#!!%$## !$\"# !\"# !*\u0157 \"!.w\"\"2w3x+\u0146$ $74*\x9B \"! $!!8.c\"\"2c3d9*$$\"\" -\"# !+3$0y\"\"1!3z+#%'\"%$\"# !\"# !+U$,R&!!8.c\"\"2c3d9*$$\"\" -\"# !+3$0y\"\"1!3z+#%'\"%$\"# !\"# !\"\"\" !+& 4!6u! %,\xA1&74*\x9B \"! $!!8.c\"\"2c3d9*$$\"\" -\"# !+3$0y\"\"1!3z+#%'\"%$\"# !\"# !+U$,R&!!8.c\"\"2c3d9*$$\"\" -\"# !+3$0y\"\"1!3z+#%'\"%$\"# !\"# !\"\"\" !+& 4!6u! %\"+8%.w\"\"2w3x+(%4#6v#!!%$## !$\"# !\"# !"), peg$decode("!.c\"\"2c3d+V$7Z+L%76+B%7Z+8%.{\"\"2{3|+(%4%6}%!\"%$%# !$$# !$## !$\"# !\"# !"), peg$decode("!74+' 4!6~!! %"), peg$decode("!79+^$.\"\"23\x80+N%76+D%.\x81\"\"2\x813\x82+4%76+*%4%6\x83%#$\" %$%# !$$# !$## !$\"# !\"# !*# \"79"), peg$decode("!.\x84\"\"2\x843\x85+B$78+8%.\x86\"\"2\x863\x87+(%4#6\x88#!!%$## !$\"# !\"# !*4 \"!.\x89\"\"2\x893\x8A+& 4!6\x8B! %"), peg$decode("!76+q$ $!.\x8C\"\"2\x8C3\x8D+-$76+#%'\"%$\"# !\"# !,>&!.\x8C\"\"2\x8C3\x8D+-$76+#%'\"%$\"# !\"# !\"+)%4\"6\x8E\"\"! %$\"# !\"# !"), peg$decode("!7>+C$.l\"\"2l3m+3%79+)%4#6\x8F#\"\" %$## !$\"# !\"# !*# \"7:"), peg$decode("!7;+\u0104$.\x90\"\"2\x903\x91*\xDD \".\x92\"\"2\x923\x93*\xD1 \".\x94\"\"2\x943\x95*\xC5 \".\x96\"\"2\x963\x97*\xB9 \".\x98\"\"2\x983\x99*\xAD \".\x9A\"\"2\x9A3\x9B*\xA1 \".\x9C\"\"2\x9C3\x9D*\x95 \".\x9E\"\"2\x9E3\x9F*\x89 \".'\"\"2'3(*} \".\xA0\"\"2\xA03\xA1*q \".\xA2\"\"2\xA23\xA3*e \".8\"\"2839*Y \".\xA4\"\"2\xA43\xA5*M \".\xA6\"\"2\xA63\xA7*A \".\xA8\"\"2\xA83\xA9*5 \".\xAA\"\"2\xAA3\xAB*) \".\xAC\"\"2\xAC3\xAD+4%7:+*%4#6\xAE##\"! %$## !$\"# !\"# !*# \"7;"), peg$decode("!7Z+<$7<+2%7Z+(%4#6\xAF#!!%$## !$\"# !\"# !"), peg$decode("!7?+;$ $7=,#&7=\"+)%4\"6\xB0\"\"! %$\"# !\"# !*) \"7J*# \"7>"), peg$decode("!.\xB1\"\"2\xB13\xB2+W$7Z+M%7O+C%77*# \" Z+3%7Z+)%4%6\xB3%\"\"!%$%# !$$# !$## !$\"# !\"# !"), peg$decode("!7Z+<$7@+2%7Z+(%4#6\xB4#!!%$## !$\"# !\"# !"), peg$decode("!.\xB5\"\"2\xB53\xB6+3$7?+)%4\"6\xB7\"\"! %$\"# !\"# !*b \"!.\xB5\"\"2\xB53\xB6*) \".\xA6\"\"2\xA63\xA7+3$7?+)%4\"6\xB8\"\"! %$\"# !\"# !*/ \"7D*) \"7J*# \"7>"), peg$decode("7C*5 \"7P*/ \"7A*) \"7U*# \"7K"), peg$decode("!!.\xA6\"\"2\xA63\xA7*# \" Z+i$! $0\xB9\"\"1!3\xBA+,$,)&0\xB9\"\"1!3\xBA\"\"\" !+3$7B*# \" Z+#%'\"%$\"# !\"# !*# \"7B+#%'\"%$\"# !\"# !+' 4!6\xBB!! %"), peg$decode("!.\xBC\"\"2\xBC3\xBD+H$ $0\xB9\"\"1!3\xBA+,$,)&0\xB9\"\"1!3\xBA\"\"\" !+#%'\"%$\"# !\"# !"), peg$decode("!.\x84\"\"2\x843\x85+B$76+8%.\x86\"\"2\x863\x87+(%4#6\xBE#!!%$## !$\"# !\"# !"), peg$decode("!7E*5 \"7F*/ \"7I*) \"7G*# \"7H+' 4!6\xBF!! %"), peg$decode("!.\xC0\"\"2\xC03\xC1*) \".\xC2\"\"2\xC23\xC3+' 4!6\xC4!! %"), peg$decode("!.\xC5\"\"2\xC53\xC6+& 4!6\xC7! %"), peg$decode("!.\xC8\"\"2\xC83\xC9+& 4!6\xCA! %"), peg$decode("!.\xCB\"\"2\xCB3\xCC+& 4!6\xCD! %"), peg$decode("!.\xCE\"\"2\xCE3\xCF*) \".\xD0\"\"2\xD03\xD1+& 4!6\xD2! %"), peg$decode("!7>+3$77+)%4\"6\xD3\"\"! %$\"# !\"# !"), peg$decode("!.\xD4\"\"2\xD43\xD5*M \".\xD6\"\"2\xD63\xD7*A \".\xD8\"\"2\xD83\xD9*5 \".\xDA\"\"2\xDA3\xDB*) \".\xDC\"\"2\xDC3\xDD*# \" Z+Z$7Z+P%7O+F% $7L,#&7L\"+4%7Z+*%4%6\xDE%#$\"!%$%# !$$# !$## !$\"# !\"# !"), peg$decode("7M*# \"7N"), peg$decode("!.\xBC\"\"2\xBC3\xBD+2$7O+(%4\"6\xDF\"! %$\"# !\"# !"), peg$decode("!.\xE0\"\"2\xE03\xE1+B$76+8%.\xE2\"\"2\xE23\xE3+(%4#6\xE4#!!%$## !$\"# !\"# !"), peg$decode("! $0\xE5\"\"1!3\xE6+,$,)&0\xE5\"\"1!3\xE6\"\"\" !+' 4!6\xE7!! %"), peg$decode("!.\xE8\"\"2\xE83\xE9+\\$7Z+R%7Q*# \" Z+B%7Z+8%.\xEA\"\"2\xEA3\xEB+(%4%6\xEC%!\"%$%# !$$# !$## !$\"# !\"# !"), peg$decode("!7R+' 4!6\xED!! %"), peg$decode("!7S+q$ $!.\x8C\"\"2\x8C3\x8D+-$7R+#%'\"%$\"# !\"# !,>&!.\x8C\"\"2\x8C3\x8D+-$7R+#%'\"%$\"# !\"# !\"+)%4\"6\xEE\"\"! %$\"# !\"# !"), peg$decode("!7Z+]$7T+S%7Z+I%.\x81\"\"2\x813\x82+9%76*# \" Z+)%4%6\xEF%\"# %$%# !$$# !$## !$\"# !\"# !"), peg$decode("!7U+' 4!6\xF0!! %*/ \"!7O+' 4!6\xF1!! %"), peg$decode("8!.q\"\"2q3r+J$ $7V,#&7V\"+8%.q\"\"2q3r+(%4#6\xF3#!!%$## !$\"# !\"# !*[ \"!.w\"\"2w3x+J$ $7W,#&7W\"+8%.w\"\"2w3x+(%4#6\xF3#!!%$## !$\"# !\"# !9*\" 3\xF2"), peg$decode("!!8.q\"\"2q3r*) \".\xF4\"\"2\xF43\xF59*$$\"\" -\"# !+1$7X+'%4\"6\xF6\" %$\"# !\"# !*) \".\xF7\"\"2\xF73\xF8"), peg$decode("!!8.w\"\"2w3x*) \".\xF4\"\"2\xF43\xF59*$$\"\" -\"# !+1$7X+'%4\"6\xF6\" %$\"# !\"# !*) \".\xF9\"\"2\xF93\xFA"), peg$decode("-\"\"1!3\xFB"), peg$decode("! $0\xFC\"\"1!3\xFD+,$,)&0\xFC\"\"1!3\xFD\"\"\" !+' 4!6\xFE!! %"), peg$decode(" $0\xFF\"\"1!3\u0100,)&0\xFF\"\"1!3\u0100\"")],
            peg$currPos = 0,
            peg$reportedPos = 0,
            peg$cachedPos = 0,
            peg$cachedPosDetails = {
            line: 1,
            column: 1,
            seenCR: false
            },
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$silentFails = 0,
            peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleIndices)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }
          peg$startRuleIndex = peg$startRuleIndices[options.startRule];
        }

        function text() {
          return input.substring(peg$reportedPos, peg$currPos);
        }

        function offset() {
          return peg$reportedPos;
        }

        function line() {
          return peg$computePosDetails(peg$reportedPos).line;
        }

        function column() {
          return peg$computePosDetails(peg$reportedPos).column;
        }

        function expected(description) {
          throw peg$buildException(null, [{
            type: "other",
            description: description
          }], peg$reportedPos);
        }

        function error(message) {
          throw peg$buildException(message, null, peg$reportedPos);
        }

        function peg$computePosDetails(pos) {
          function advance(details, startPos, endPos) {
            var p, ch;
            for (p = startPos; p < endPos; p++) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              }
              else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              }
              else {
                details.column++;
                details.seenCR = false;
              }
            }
          }
          if (peg$cachedPos !== pos) {
            if (peg$cachedPos > pos) {
              peg$cachedPos = 0;
              peg$cachedPosDetails = {
                line: 1,
                column: 1,
                seenCR: false
              };
            }
            advance(peg$cachedPosDetails, peg$cachedPos, pos);
            peg$cachedPos = pos;
          }
          return peg$cachedPosDetails;
        }

        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected);
        }

        function peg$buildException(message, expected, pos) {
          function cleanupExpected(expected) {
            var i = 1;
            expected.sort(function (a, b) {
              if (a.description < b.description) {
                return -1;
              }
              else if (a.description > b.description) {
                return 1;
              }
              else {
                return 0;
              }
            });
            while (i < expected.length) {
              if (expected[i - 1] === expected[i]) {
                expected.splice(i, 1);
              }
              else {
                i++;
              }
            }
          }

          function buildMessage(expected, found) {
            function stringEscape(s) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
                return '\\x0' + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
                return '\\x' + hex(ch);
              }).replace(/[\u0180-\u0FFF]/g, function (ch) {
                return '\\u0' + hex(ch);
              }).replace(/[\u1080-\uFFFF]/g, function (ch) {
                return '\\u' + hex(ch);
              });
            }
            var expectedDescs = new Array(expected.length),
                expectedDesc, foundDesc, i;
            for (i = 0; i < expected.length; i++) {
              expectedDescs[i] = expected[i].description;
            }
            expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
            foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          var posDetails = peg$computePosDetails(pos),
              found = pos < input.length ? input.charAt(pos) : null;
          if (expected !== null) {
            cleanupExpected(expected);
          }
          return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
        }

        function peg$decode(s) {
          var bc = new Array(s.length),
              i;
          for (i = 0; i < s.length; i++) {
            bc[i] = s.charCodeAt(i) - 32;
          }
          return bc;
        }

        function peg$parseRule(index) {
          var bc = peg$bytecode[index],
              ip = 0,
              ips = [],
              end = bc.length,
              ends = [],
              stack = [],
              params, i;

          function protect(object) {
            return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
          }
          while (true) {
            while (ip < end) {
              switch (bc[ip]) {
              case 0:
                stack.push(protect(peg$consts[bc[ip + 1]]));
                ip += 2;
                break;
              case 1:
                stack.push(peg$currPos);
                ip++;
                break;
              case 2:
                stack.pop();
                ip++;
                break;
              case 3:
                peg$currPos = stack.pop();
                ip++;
                break;
              case 4:
                stack.length -= bc[ip + 1];
                ip += 2;
                break;
              case 5:
                stack.splice(-2, 1);
                ip++;
                break;
              case 6:
                stack[stack.length - 2].push(stack.pop());
                ip++;
                break;
              case 7:
                stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
                ip += 2;
                break;
              case 8:
                stack.pop();
                stack.push(input.substring(stack[stack.length - 1], peg$currPos));
                ip++;
                break;
              case 9:
                ends.push(end);
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                if (stack[stack.length - 1]) {
                  end = ip + 3 + bc[ip + 1];
                  ip += 3;
                }
                else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                  ip += 3 + bc[ip + 1];
                }
                break;
              case 10:
                ends.push(end);
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                if (stack[stack.length - 1] === peg$FAILED) {
                  end = ip + 3 + bc[ip + 1];
                  ip += 3;
                }
                else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                  ip += 3 + bc[ip + 1];
                }
                break;
              case 11:
                ends.push(end);
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                if (stack[stack.length - 1] !== peg$FAILED) {
                  end = ip + 3 + bc[ip + 1];
                  ip += 3;
                }
                else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                  ip += 3 + bc[ip + 1];
                }
                break;
              case 12:
                if (stack[stack.length - 1] !== peg$FAILED) {
                  ends.push(end);
                  ips.push(ip);
                  end = ip + 2 + bc[ip + 1];
                  ip += 2;
                }
                else {
                  ip += 2 + bc[ip + 1];
                }
                break;
              case 13:
                ends.push(end);
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                if (input.length > peg$currPos) {
                  end = ip + 3 + bc[ip + 1];
                  ip += 3;
                }
                else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                  ip += 3 + bc[ip + 1];
                }
                break;
              case 14:
                ends.push(end);
                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                  end = ip + 4 + bc[ip + 2];
                  ip += 4;
                }
                else {
                  end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                  ip += 4 + bc[ip + 2];
                }
                break;
              case 15:
                ends.push(end);
                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                  end = ip + 4 + bc[ip + 2];
                  ip += 4;
                }
                else {
                  end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                  ip += 4 + bc[ip + 2];
                }
                break;
              case 16:
                ends.push(end);
                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                  end = ip + 4 + bc[ip + 2];
                  ip += 4;
                }
                else {
                  end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                  ip += 4 + bc[ip + 2];
                }
                break;
              case 17:
                stack.push(input.substr(peg$currPos, bc[ip + 1]));
                peg$currPos += bc[ip + 1];
                ip += 2;
                break;
              case 18:
                stack.push(peg$consts[bc[ip + 1]]);
                peg$currPos += peg$consts[bc[ip + 1]].length;
                ip += 2;
                break;
              case 19:
                stack.push(peg$FAILED);
                if (peg$silentFails === 0) {
                  peg$fail(peg$consts[bc[ip + 1]]);
                }
                ip += 2;
                break;
              case 20:
                peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
                ip += 2;
                break;
              case 21:
                peg$reportedPos = peg$currPos;
                ip++;
                break;
              case 22:
                params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
                for (i = 0; i < bc[ip + 3]; i++) {
                  params[i] = stack[stack.length - 1 - params[i]];
                }
                stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));
                ip += 4 + bc[ip + 3];
                break;
              case 23:
                stack.push(peg$parseRule(bc[ip + 1]));
                ip += 2;
                break;
              case 24:
                peg$silentFails++;
                ip++;
                break;
              case 25:
                peg$silentFails--;
                ip++;
                break;
              default:
                throw new Error("Invalid opcode: " + bc[ip] + ".");
              }
            }
            if (ends.length > 0) {
              end = ends.pop();
              ip = ips.pop();
            }
            else {
              break;
            }
          }
          return stack[0];
        } /*jshint laxcomma:false */

        function trimWhitespace(ws) {
          return trimNewLineChars(ws).replace(/(^[\r\n]+)|([\r\n]+$)/, " ");
        }

        function trimEnds(ws) {
          return ws.replace(/(^\s+)|(\s+$)/, "").replace(/[\r\n]/g, "\\n");
        }

        function trimNewLineChars(ws) {
          return ws.replace(/[ \r\n\t]+/g, " ");
        }

        function trimmedText() {
          return trimWhitespace(text());
        }

        function attrValues(values) {
          values = values.filter(function (v) {
            return !/^[\n\t\r]+$/.test(v.value);
          });
          if (values.length === 1 && values[0].type === "string") {
            return values[0];
          }
          else {
            return values;
          }
        }

        function trimTextExpressions(expressions) {
          function _trim(exprs) {
            var expr;
            for (var i = exprs.length; i--;) {
              expr = exprs[i];
              if (expr.type == "textNode" && !/\S/.test(expr.value) && !expr.decoded) {
                exprs.splice(i, 1);
              }
              else {
                break;
              }
            }
            return exprs;
          }
          return _trim(_trim(expressions.reverse()).reverse());
        }

        function expression(name) {
          return Array.prototype.slice.call(arguments);
        }

        function escapeString(string) {
          return string.replace(/[\n\r]+/g, "\\n").replace(/'/g, "\\'");
        }
        peg$result = peg$parseRule(peg$startRuleIndex);
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        }
        else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({
              type: "end",
              description: "end of input"
            });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
      }
      return {
        SyntaxError: SyntaxError,
        parse: parse
      };
    })();
  })(parser || (parser = {}));
  var vnode;
  (function (vnode) {
    var NodeSection = (function () {
      function NodeSection(document, node) {
        this.document = document;
        this.node = node;
      }
      NodeSection.prototype.createMarker = function () {
        return new NodeSectionMarker(this.document, vnode.getNodePath(this.node));
      };
      NodeSection.prototype.appendChild = function (node) {
        this.node.appendChild(node);
      };
      NodeSection.prototype.render = function () {
        return this.node;
      };
      NodeSection.prototype.remove = function () {
        if (this.node.parentNode) this.node.parentNode.removeChild(this.node);
      };
      NodeSection.prototype.removeChildren = function () {
        while (this.node.childNodes.length)
        this.node.removeChild(this.node.childNodes[0]);
      };
      NodeSection.prototype.clone = function () {
        return new NodeSection(this.document, this.node.cloneNode(true));
      };
      return NodeSection;
    })();
    vnode.NodeSection = NodeSection;
    var NodeSectionMarker = (function () {
      function NodeSectionMarker(document, path) {
        this.document = document;
        this.path = path;
      }
      NodeSectionMarker.prototype.createSection = function (root) {
        return new NodeSection(this.document, this.findNode(root));
      };
      NodeSectionMarker.prototype.findNode = function (root) {
        return vnode.getNodeByPath(root, this.path);
      };
      return NodeSectionMarker;
    })();
    vnode.NodeSectionMarker = NodeSectionMarker;
  })(vnode || (vnode = {}));
  var vnode;
  (function (vnode) {
    var FragmentSection = (function () {
      function FragmentSection(document, start, end) {
        this.document = document;
        this.start = start || document.createTextNode('');
        this.end = end || document.createTextNode('');
        if (!this.start.parentNode) {
          var parent_1 = document.createDocumentFragment();
          parent_1.appendChild(this.start);
          parent_1.appendChild(this.end);
        }
      }
      FragmentSection.prototype.appendChild = function (node) {
        //console.log(document.body.appendChild(node))
        this.end.parentNode.insertBefore(node, this.end);
      };
      FragmentSection.prototype.render = function () {
        return this.start.parentNode;
      };
      FragmentSection.prototype.remove = function () {
        var node = this.removeChildNodes();
        node.insertBefore(this.start, node.childNodes[0]);
        node.appendChild(this.end);
        return this;
      };
      FragmentSection.prototype.removeChildNodes = function () {
        var node = this.document.createDocumentFragment(),
            start = this.start;
        var current = start.nextSibling;
        var end = this.end;
        while (current !== end) {
          node.appendChild(current);
          current = start.nextSibling;
        }
        return node;
      };
      FragmentSection.prototype.createMarker = function () {
        return new FragmentSectionMarker(this.document, vnode.getNodePath(this.start), vnode.getNodePath(this.end));
      };
      FragmentSection.prototype.clone = function () {
        var parentClone;
        // fragment?
        if (this.start.parentNode.nodeType === 11) {
          parentClone = this.start.parentNode.cloneNode(true);
        }
        else {
          parentClone = this.document.createDocumentFragment();
          var children = this._getChildNodes();
          var n = children.length;
          for (var i = 0; i < n; i++) {
            parentClone.appendChild(children[i].cloneNode(true));
          }
        }
        var first = parentClone.childNodes[0];
        var last = parentClone.childNodes[parentClone.childNodes.length - 1];
        return new FragmentSection(this.document, first, last);
      };
      FragmentSection.prototype._getChildNodes = function () {
        var current = this.start;
        var end = this.end.nextSibling;
        var children = [];
        while (current !== end) {
          children.push(current);
          current = current.nextSibling;
        }
        return children;
      };
      return FragmentSection;
    })();
    vnode.FragmentSection = FragmentSection;
    var FragmentSectionMarker = (function () {
      function FragmentSectionMarker(document, startPath, endPath) {
        this.document = document;
        this.startPath = startPath;
        this.endPath = endPath;
      }
      FragmentSectionMarker.prototype.createSection = function (root) {
        return new vnode.FragmentSection(this.document, vnode.getNodeByPath(root, this.startPath), vnode.getNodeByPath(root, this.endPath));
      };
      return FragmentSectionMarker;
    })();
    vnode.FragmentSectionMarker = FragmentSectionMarker;
  })(vnode || (vnode = {}));
  var vnode;
  (function (vnode) {
    function section(document, node) {
      var section;
      if (node.nodeType == vnode.NodeType.Fragment) {
        var frag = new vnode.FragmentSection(document);
        frag.appendChild(node);
        section = frag;
      }
      else {
        section = new vnode.NodeSection(document, node);
      }
      return section;
    }
    vnode.section = section;
  })(vnode || (vnode = {}));
  var vnode;
  (function (vnode) {
    var View = (function () {
      function View(section, template, context, options) {
        this.section = section;
        this.template = template;
        this.context = context;
        this.bindings = [];
      }
      View.prototype.update = function () {
        for (var _i = 0, _a = this.bindings; _i < _a.length; _i++) {
          var binding = _a[_i];
          binding.update();
        }
      };
      View.prototype.render = function () {
        return this.section.render();
      };
      View.prototype.remove = function () {
        for (var _i = 0, _a = this.bindings; _i < _a.length; _i++) {
          var binding = _a[_i];
          binding.destroy();
        }
        return this.section.remove();
      };
      return View;
    })();
    vnode.View = View;
  })(vnode || (vnode = {}));
  var vnode;
  (function (vnode_1) {
    var Template = (function () {
      function Template(vnode, options) {
        this._renderers = [];
        this.vnode = vnode;
        var node = vnode.render(options, this._renderers);
        this.section = vnode_1.section(options.document, node);
        this.options = options;
      }
      Template.prototype.view = function (context, options) {
        var section = this.section.clone();
        var DestView = this.options.viewClass || vnode_1.View;
        var view = new DestView(section, this, context, options);
        for (var _i = 0, _a = this._renderers; _i < _a.length; _i++) {
          var renderer = _a[_i];
          renderer.generate(section.node || section.start.parentNode, view);
        }
        return view;
      };
      return Template;
    })();
    vnode_1.Template = Template;

    function template(vnode, options) {
      return new Template(vnode, options);
    }
    vnode_1.template = template;
  })(vnode || (vnode = {}));
  var vnode;
  (function (vnode_2) {
    (function (NodeType) {
      NodeType[NodeType["Element"] = 1] = "Element";
      NodeType[NodeType["Fragment"] = 11] = "Fragment";
      NodeType[NodeType["Comment"] = 8] = "Comment";
      NodeType[NodeType["Dynamic"] = -200] = "Dynamic";
      NodeType[NodeType["Text"] = -201] = "Text";
    })(vnode_2.NodeType || (vnode_2.NodeType = {}));
    var NodeType = vnode_2.NodeType;

    function getNodeByPath(root, path) {
      var c = root;
      for (var i = 0, n = path.length; i < n; i++) {
        c = c.childNodes[path[i]];
      }
      return c;
    }
    vnode_2.getNodeByPath = getNodeByPath;

    function getNodePath(node) {
      var path = [];
      var p = node.parentNode;
      var c = node;
      while (p) {
        path.unshift(Array.prototype.indexOf.call(p.childNodes, c));
        c = p;
        p = p.parentNode;
        // virtual nodes - must be skipped
        while (p && p.nodeType > 12)
        p = p.parentNode;
      }
      return path;
    }
    vnode_2.getNodePath = getNodePath;
  })(vnode || (vnode = {}));
  var parser;
  (function (parser) {
    function transpile(source) {
      var transpiler = new Transpiler();
      return transpiler.transpile(source);
    }
    parser.transpile = transpile;
    /**
     * Transpile AST to Function
     */
    var Transpiler = (function () {
      function Transpiler() {
        for (var k in this) {
          if (k.charAt(0) === "_") {
            this[k] = this[k].bind(this);
          }
        }
        this.transpile = this.transpile.bind(this);
      }
      /**
       */
      Transpiler.prototype.transpile = function (source) {
        return this._root(parser.parser.parse(source));
      };
      /**
       */
      Transpiler.prototype._root = function (elements) {
        var buffer = "(function(fragment, element, text, comment, dynamic, createBindingClass) {";
        var fragment = "fragment([" + this._children(elements) + "])";
        buffer += "'use strict';return " + fragment;
        buffer += "})";
        return buffer;
      };
      /**
       */
      Transpiler.prototype._expression = function (expression) {
        return this["_" + expression[0]](expression);
      };
      /**
       * check for stuff like <li repeat.each={{items}}></li>
       */
      Transpiler.prototype._element = function (expression) {
        var exprs = {};
        var prev = expression;
        var attrs = [];
        expression[2].forEach(function (attr, i) {
          var key = attr[1];
          var value = attr[2];
          var keyParts = key.split(".");
          // check for things like <li repeat.each={{items}}></li>
          if (keyParts.length > 1) {
            if (!exprs[keyParts[0]]) {
              expression = exprs[keyParts[0]] = ["element", keyParts[0],
                [],
                [
                  ["element", expression[1], attrs, expression[3]]
                ]
              ];
            }
            exprs[keyParts[0]][2].push([attr[0], keyParts[1], value]);
          }
          else {
            attrs.push(attr);
          }
        });
        return this._element2(expression);
      };
      /**
       */
      Transpiler.prototype._doctype = function (expression) {
        return "text('<!DOCTYPE " + expression[1] + ">')";
      };
      /**
       */
      Transpiler.prototype._children = function (children) {
        var items = [];
        children = children.concat();
        while (children.length) {
          var child = children[children.length - 1];
          if (child[0] !== "text") break;
          child[1] = child[1].replace(/[\s\r\n\t]+$/, "");
          if (/^[\s\r\n\t]*$/.test(child[1])) {
            children.pop();
          }
          else {
            break;
          }
        }
        return children.map(this._expression).join(", ");
      };
      /**
       */
      Transpiler.prototype._element2 = function (expression) {
        var buffer = "element('" + expression[1] + "'";
        var dynamicAttributes = [];
        buffer += ", {";
        var attrs = [];
        buffer += expression[2].map(function (attr) {
          var key = attr[1];
          var value = attr[2];
          if (!value.length || (value.length === 1 && value[0][0] === "string")) {
            return "'" + key + "':" + (value.length ? this._expression(value[0]) : "true");
          }
          else {
            dynamicAttributes.push(attr);
          }
        }.bind(this)).filter(function (str) {
          return !!str;
        }).join(",");
        buffer += "}";
        var childBuffer = this._children(expression[3]);
        if (childBuffer.length) {
          buffer += ", " + childBuffer;
        }
        buffer += ")";
        if (dynamicAttributes.length) {
          var dynamicAttrBuffer = "";
          var staticAttrBuffer = "";
          dynamicAttributes.forEach(function (expression) {
            var type = expression[0];
            // var key  = _dashToCamelCase(expression[1]);
            dynamicAttrBuffer += "this";
            if (type === "block") {
              dynamicAttrBuffer += ".ref.nodeValue = " + this._expression(expression[1]);
            }
            else if (type === "attribute") {
              var value = expression[2].map(function (expr) {
                return "(" + this._expression(expr) + ")";
              }.bind(this)).join("+");
              dynamicAttrBuffer += ".setAttribute('" + expression[1] + "', " + value + ");";
            }
            else if (type === "property") {
              // dynamicAttrBuffer += ".ref." + expression[1] + "=" + this._expression(expression[2]);
              dynamicAttrBuffer += ".setProperty('" + expression[1] + "', " + this._expression(expression[2]) + ");";
            }
          }.bind(this));
          if (dynamicAttrBuffer.length) {
            dynamicAttrBuffer = "function(context) {" + dynamicAttrBuffer + "}";
          }
          if (staticAttrBuffer.length) {
            staticAttrBuffer = "function() { var self = this; " + staticAttrBuffer + "}";
          }
          if (dynamicAttrBuffer.length || staticAttrBuffer.length) {
            buffer = "dynamic(" + buffer + ",";
            buffer += "createBindingClass(" + (staticAttrBuffer.length ? staticAttrBuffer : "void 0") + ", " + (dynamicAttrBuffer ? dynamicAttrBuffer : "void 0") + ")";
            buffer += ")";
          }
        }
        return buffer;
      };
      /**
       */
      Transpiler.prototype.__addReference = function (expression) {
        var name = "_" + (++this._refCounter);
        this._refs[name] = expression;
        return name;
      };
      /**
       */
      Transpiler.prototype._block = function (expression) {
        // TODO - check for unbound expressions here
        var buffer = "dynamic(text(), createBindingClass(void 0, function(context) {";
        buffer += "this.ref.nodeValue = " + this._expression(expression[1]) + ";";
        return buffer + "}))";
      };
      /**
       */
      Transpiler.prototype._text = function (expression) {
        return "text('" + expression[1] + "')";
      };
      /**
       */
      Transpiler.prototype._comment = function (expression) {
        return "comment('" + expression[1] + "')";
      };
      /**
       */
      Transpiler.prototype._hash = function (expression) {
        var items = expression[1];
        var buffer = [];
        for (var key in items) {
          buffer.push("'" + key + "':" + this._expression(items[key]));
        }
        return "{" + buffer.join(",") + "}";
      };
      /**
       */
      Transpiler.prototype._script = function (expression) {
        return this._expression(expression[1]);
      };
      /**
       */
      Transpiler.prototype._referenceKeyPath = function (expression) {
        var keypath = [];
        var isDynamic = false;
        expression.forEach(function (part) {
          if (typeof part !== "string") {
            isDynamic = true;
            // console.log(expression);
            keypath.push(this._expression(part));
          }
          else {
            keypath.push(part);
          }
        }.bind(this));
        keypath = (isDynamic ? "[" + keypath.map(function (part, i) {
          return typeof expression[i] === "string" ? "'" + part + "'" : part;
        }).join(",") + "]" : "'" + keypath.join(".") + "'");
        return keypath;
      };
      /**
       */
      Transpiler.prototype._reference = function (expression) {
        var keypath = this._referenceKeyPath(expression[1]);
        if (expression[2]) {
          var gettable = !! ~expression[2].indexOf("<~");
          var settable = !! ~expression[2].indexOf("~>");
          return "this.view.ref(" + keypath + ", " + gettable + ", " + settable + ")";
        }
        return "this.view.get(" + keypath + ")";
      };
      /**
       */
      Transpiler.prototype._string = function (expression) {
        return "'" + expression[1] + "'";
      };
      /**
       */
      Transpiler.prototype._operator = function (expression) {
        return this._expression(expression[2]) + expression[1] + this._expression(expression[3]);
      };
      /**
       */
      Transpiler.prototype._condition = function (expression) {
        return this._expression(expression[1]) + "?" + this._expression(expression[2]) + ":" + this._expression(expression[3]);
      };
      /**
       */
      Transpiler.prototype._literal = function (expression) {
        return expression[1];
      };
      /**
       */
      Transpiler.prototype._not = function (expression) {
        return "!" + this._expression(expression[1]);
      };
      /**
       */
      Transpiler.prototype._negative = function (expression) {
        return "-" + this._expression(expression[1]);
      };
      /**
       */
      Transpiler.prototype._call = function (expression) {
        var buffer = "this.view.call(" + this._referenceKeyPath(expression[1][1]) + ", [";
        buffer += expression[2].map(this._expression).join(",");
        return buffer + "])";
      };
      /**
       */
      Transpiler.prototype._modifier = function (expression) {
        return "this.options.modifiers." + expression[1] + "(" + expression[2].map(this._expression).join(",") + ")";
      };
      Transpiler.prototype._assign = function (expression) {
        return 'this.view.assign("' + expression[1][1] + '", ' + 'function () { return ' + this._expression(expression[2]) + ';})';
      };
      /**
       */
      Transpiler.prototype._group = function (expression) {
        return "(" + this._expression(expression[1]) + ")";
      };
      /**
       */
      Transpiler.prototype.__findExpressions = function (type, expr) {
        var exprs = [];
        this.__traverse(expr, function (expr) {
          if (expr[0] === type) exprs.push(expr);
        });
        return exprs;
      };
      /**
       */
      Transpiler.prototype.__traverse = function (expr, iterator) {
        iterator(expr);
        expr.forEach(function (v) {
          if (v && typeof v === "object") {
            this.__traverse(v, iterator);
          }
        }.bind(this));
      };
      return Transpiler;
    })();
  })(parser || (parser = {}));
  /**
   */

  function _dashToCamelCase(string) {
    return string.split("-").map(function (part, i) {
      var p = part.toLowerCase();
      return i > 0 ? p.charAt(0).toUpperCase() + p.substr(1) : p;
    }).join("");
  }
  /**
   */
  var parser;
  (function (parser) {
    function compile(src, options) {
      var str = parser.transpile(src);
      return new Function("return " + str)();
    }
    parser.compile = compile;
  })(parser || (parser = {}));
  var utils;
  (function (utils) {
    function extend(obj) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var a, k;
      for (var _a = 0; _a < args.length; _a++) {
        a = args[_a];
        if (a !== Object(a)) continue;
        for (k in a)
        obj[k] = a[k];
      }
      return obj;
    }
    utils.extend = extend;

    function slice(obj) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return Array.prototype.slice.apply(obj, args);
    }
    utils.slice = slice;

    function extendClass(parent, protoProps, staticProps) {
      var child;
      // The constructor function for the new subclass is either defined by you
      // (the "constructor" property in your `extend` definition), or defaulted
      // by us to simply call the parent constructor.
      if (protoProps && Object.prototype.hasOwnProperty.call(protoProps, 'constructor')) {
        child = protoProps.constructor;
      }
      else {
        child = function () {
          return parent.apply(this, arguments);
        };
      }
      // Add static properties to the constructor function, if supplied.
      extend(child, parent, staticProps);
      // Set the prototype chain to inherit from `parent`, without calling
      // `parent` constructor function.
      var Surrogate = function () {
        this.constructor = child;
      };
      Surrogate.prototype = parent.prototype;
      child.prototype = new Surrogate;
      // Add prototype properties (instance properties) to the subclass,
      // if supplied.
      if (protoProps) extend(child.prototype, protoProps);
      // Set a convenience property in case the parent's prototype is needed
      // later.
      child.__super__ = parent.prototype;
      return child;
    }
    utils.extendClass = extendClass;;
    var nativeBind = Function.prototype.bind;

    function bind(method, context) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (typeof method !== 'function') throw new Error('method not at function');
      if (nativeBind != null) return nativeBind.call.apply(nativeBind, [method, context].concat(args));
      args = args || [];
      var fnoop = function () {};
      var fBound = function () {
        var ctx = this instanceof fnoop ? this : context;
        return method.apply(ctx, args.concat(utils.slice(arguments)));
      };
      fnoop.prototype = this.prototype;
      fBound.prototype = new fnoop();
      return fBound;
    }
    utils.bind = bind;
    var Debug = (function () {
      function Debug(namespace) {
        this.enabled = false;
        this.namespace = namespace;
      }
      Debug.enable = function (enabled, namespace) {
        for (var k in this.loggers) {
          if (namespace && k === namespace) {
            this.loggers[k].enabled = enabled;
          }
          else if (!namespace) {
            this.loggers[k].enabled = enabled;
          }
        }
      };
      Debug.create = function (namespace) {
        var logger;
        if (this.loggers[namespace]) {
          logger = this.loggers[namespace].debug;
        }
        else {
          logger = new Debug(namespace);
          this.loggers[namespace] = logger;
        }
        return bind(logger.debug, logger);
      };
      Debug.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i - 0] = arguments[_i];
        }
        if (!this.enabled) return;
        args[0] = this._coerce(args[0]);
        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %o
          args = ['%o'].concat(args);
        }
        // apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = Debug.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        args = this._formatArgs(args);
        this._log.apply(this, args);
      };
      Debug.prototype._log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i - 0] = arguments[_i];
        }
        return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
      };
      Debug.prototype._coerce = function (val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
      };
      Debug.prototype._formatArgs = function (args) {
        args[0] = '[templ:' + this.namespace + '] ' + args[0];
        return args;
      };
      Debug.loggers = {};
      Debug.formatters = {
        j: function (args) {
          return JSON.stringify(args);
        }
      };
      return Debug;
    })();
    utils.Debug = Debug;

    function debug(namespace) {
      return Debug.create(namespace);
    }
    utils.debug = debug;
  })(utils || (utils = {}));
  var engine;
  (function (engine) {
    var Binding = (function () {
      function Binding(ref, view) {
        this._attributeClasses = {};
        this._attrBindings = {};
        this.ref = ref;
        this.view = view;
        this.options = view.template.options;
        this._attributeClasses = this.options.attributes;
      }
      Binding.prototype.setAttribute = function (key, value) {
        if (!this.setAsRegisteredAttribute(key, value)) {
          if (value != void 0) {
            this.ref.setAttribute(key, value);
          }
          else {}
        }
      };
      Binding.prototype.setAsRegisteredAttribute = function (key, value) {
        if (this._attrBindings[key]) {
          this._attrBindings[key].value = value;
        }
        else {
          var attrClass = this._attributeClasses[key];
          if (attrClass) {
            this._attrBindings[key] = new attrClass(this.ref, key, value, this.view);
          }
          else {
            return false;
          }
        }
        return true;
      };
      Binding.prototype.update = function (context) {
        this._update();
        for (var key in this._attrBindings) {
          this._attrBindings[key].update();
        }
      };
      Binding.prototype.destroy = function () {
        for (var key in this._attrBindings) {
          this._attrBindings[key].destroy();
        }
      };
      return Binding;
    })();
    engine.Binding = Binding;

    function binding(initialize, update) {
      return utils.extendClass(Binding, {
        initialize: initialize ||
        function () {},
        _update: update ||
        function () {}
      });
    }
    engine.binding = binding;
  })(engine || (engine = {}));
  var vnode;
  (function (vnode) {
    var Text = (function () {
      function Text(nodeValue) {
        this.nodeType = vnode.NodeType.Text;
        this.nodeValue = nodeValue;
      }
      Text.prototype.render = function (options) {
        return options.document.createTextNode(this.nodeValue);
      };
      return Text;
    })();
    vnode.Text = Text;
    vnode.text = function text(nodeValue) {
      return new Text(nodeValue);
    };
  })(vnode || (vnode = {}));
  var vnode;
  (function (vnode_3) {
    var Dynamic = (function () {
      function Dynamic(vnode, bindingClass) {
        this.nodeType = vnode_3.NodeType.Dynamic;
        this.vnode = vnode;
        this.bindingClass = bindingClass;
        this.vnode.parentNode = this;
      }
      Dynamic.prototype.render = function (options, renderers) {
        if (options.components[this.vnode['tagName']]) {
          return this._renderComponent(options, renderers);
        }
        else {
          return this._renderElement(options, renderers);
        }
      };
      Dynamic.prototype._renderElement = function (options, renderers) {
        var node = this.vnode.render(options, renderers);
        renderers.push(new DynamicRenderer(node, this.bindingClass, options));
        return node;
      };
      Dynamic.prototype._renderComponent = function (options, renderers) {
        var _r = [];
        var element = this.vnode.render(options, _r);
        renderers.push(new DynamicComponentRenderer(_r[0], this.bindingClass, options));
        return element;
      };
      return Dynamic;
    })();
    vnode_3.Dynamic = Dynamic;
    vnode_3.dynamic = function (vnode, bindClass) {
      return new Dynamic(vnode, bindClass);
    };
  })(vnode || (vnode = {}));
  var DynamicComponentRenderer = (function () {
    function DynamicComponentRenderer(renderer, bindingClass, options) {
      this.renderer = renderer;
      this.bindingClass = bindingClass;
      this.options = options;
    }
    DynamicComponentRenderer.prototype.generate = function (root, view) {
      this.renderer.generate(root, view);
      var component = view.bindings[view.bindings.length - 1];
      view.bindings.splice(view.bindings.indexOf(component), 0, new this.bindingClass(component, view));
    };
    return DynamicComponentRenderer;
  })();
  var DynamicRenderer = (function () {
    function DynamicRenderer(node, bindingClass, options) {
      this.ref = node;
      this.bindingClass = bindingClass;
      this.options = options;
    }
    DynamicRenderer.prototype.generate = function (root, view) {
      if (!this._refPath) this._refPath = vnode.getNodePath(this.ref);
      view.bindings.push(new this.bindingClass(vnode.getNodeByPath(root, this._refPath), view));
    };
    return DynamicRenderer;
  })();
  var vnode;
  (function (vnode) {
    var Element = (function () {
      function Element(tagName, attributes, children) {
        this.nodeType = vnode.NodeType.Element;
        this.tagName = String(tagName).toLocaleLowerCase();
        this.childNodes = children;
        this.attributes = attributes || {};
        for (var i = 0; i < children.length; i++)
        children[i].parentNode = this;
      }
      Element.prototype.render = function (options, renderers) {
        var components = options.components || {};
        if (components[this.tagName]) {
          return this._renderComponent(components[this.tagName], options, renderers);
        }
        return this._renderElement(options, renderers);
      };
      Element.prototype.setAttributes = function (key, value) {
        if (typeof key === 'string') {
          this.attributes[key] = value;
        }
        else {
          utils.extend(this.attributes, key);
        }
      };
      Element.prototype._renderComponent = function (component, options, renderers) {
        var section = new vnode.FragmentSection(options.document);
        renderers.push(new ComponentAttributeRenderer(component, section, this, this._splitAttributes(options), options));
        return section.render();
      };
      Element.prototype._renderElement = function (options, renderers) {
        var element = options.document.createElement(this.tagName);
        var _attr = this._splitAttributes(options);
        // Set static attributes
        for (var attrKey in _attr.staticAttributes) {
          element.setAttribute(attrKey, _attr.staticAttributes[attrKey]);
        }
        for (var _i = 0, _a = this.childNodes; _i < _a.length; _i++) {
          var child = _a[_i];
          element.appendChild(child.render(options, renderers));
        }
        // Set dynamic attributes
        if (Object.keys(_attr.dynamicAttributes).length) {
          renderers.push(new ElementAttributeRenderer(new vnode.NodeSection(options.document, element), options, _attr.dynamicAttributes));
        }
        return element;
      };
      Element.prototype._splitAttributes = function (options) {
        var dynamicAttributes = {};
        var staticAttributes = {};
        if (options.attributes) {
          for (var key in this.attributes) {
            var attrClass = options.attributes[key];
            if (attrClass && (!attrClass.test || attrClass.test(this, key, this.attributes[key]))) {
              dynamicAttributes[key] = this.attributes[key];
            }
            else {
              staticAttributes[key] = this.attributes[key];
            }
          }
        }
        else {
          staticAttributes = this.attributes;
        }
        return {
          dynamicAttributes: dynamicAttributes,
          staticAttributes: staticAttributes
        };
      };
      return Element;
    })();
    vnode.Element = Element;
    vnode.element = function (tagName, attributes) {
      var children = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
      }
      return new Element(tagName, attributes, children);
    };
  })(vnode || (vnode = {}));
  var ComponentAttributeRenderer = (function () {
    function ComponentAttributeRenderer(component, section, element, attr, options) {
      this.section = section;
      this.componentClass = component;
      this.element = element;
      this.options = options;
      this.attributes = attr.staticAttributes;
      this.dynamicAttributes = attr.dynamicAttributes;
    }
    ComponentAttributeRenderer.prototype.generate = function (root, view) {
      if (!this._marker) this._marker = this.section.createMarker();
      var ref = new this.componentClass(this._marker.createSection(root), this.element, this.attributes, view);
      if (Object.keys(this.dynamicAttributes).length) {
        _hydrateDynamicAttributes(ref, this.options, this.dynamicAttributes, view);
      }
      if (ref.update) view.bindings.push(ref);
    };
    return ComponentAttributeRenderer;
  })();
  var ElementAttributeRenderer = (function () {
    function ElementAttributeRenderer(section, options, attributes) {
      this.section = section;
      this.options = options;
      this.attributes = attributes;
    }
    ElementAttributeRenderer.prototype.generate = function (root, view) {
      if (!this._marker) this._marker = this.section.createMarker();
      _hydrateDynamicAttributes(this._marker.findNode(root), this.options, this.attributes, view);
    };
    return ElementAttributeRenderer;
  })();

  function _hydrateDynamicAttributes(ref, options, dynamicAttributes, view) {
    for (var key in dynamicAttributes) {
      var clazz = options.attributes[key];
      var attr = new clazz(ref, key, dynamicAttributes[key], view);
      if (attr.update) view.bindings.push(attr);
    }
  }
  var vnode;
  (function (vnode) {
    var Fragment = (function () {
      function Fragment(children) {
        this.nodeType = vnode.NodeType.Fragment;
        this.childNodes = children;
        for (var i = 0; i < children.length; i++)
        children[i].parentNode = this;
      }
      Fragment.prototype.render = function (options, renderers) {
        var fragment = options.document.createDocumentFragment();
        for (var i = 0, n = this.childNodes.length; i < n; i++) {
          fragment.appendChild(this.childNodes[i].render(options, renderers));
        }
        return fragment;
      };
      return Fragment;
    })();
    vnode.Fragment = Fragment;
    vnode.fragment = function (children) {
      return new Fragment(children);
    };
  })(vnode || (vnode = {}));
  var vnode;
  (function (vnode) {
    var Comment = (function () {
      function Comment(nodeValue) {
        this.nodeType = vnode.NodeType.Comment;
        this.nodeValue = nodeValue;
      }
      Comment.prototype.render = function (options) {
        return options.document.createComment(this.nodeValue);
      };
      return Comment;
    })();
    vnode.Comment = Comment;
    vnode.comment = function (nodeValue) {
      return new Comment(nodeValue);
    };
  })(vnode || (vnode = {}));
  var modifiers;
  (function (modifiers) {
    function uppercase(value) {
      return String(value).toUpperCase();
    }
    modifiers.uppercase = uppercase;

    function lowercase(value) {
      return String(value).toLowerCase();
    }
    modifiers.lowercase = lowercase;

    function titlecase(value) {
      var str;
      str = String(value);
      return str.substr(0, 1).toUpperCase() + str.substr(1);
    }
    modifiers.titlecase = titlecase;

    function json(value, count, delimiter) {
      return JSON.stringify.apply(JSON, arguments);
    }
    modifiers.json = json;

    function isNaN(value) {
      return isNaN(value);
    }
    modifiers.isNaN = isNaN;
    modifiers.round = Math.round;
  })(modifiers || (modifiers = {}));
  var __extends = (this && this.__extends) ||
  function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];

    function __() {
      this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
  };
  var debug = utils.debug('view');

  function _set(target, keypath, value) {
    var keys = typeof keypath === "string" ? keypath.split(".") : keypath;
    var ct = target;
    var key;
    for (var i = 0, n = keys.length - 1; i < n; i++) {
      key = keys[i];
      if (!ct[key]) {
        ct[key] = {};
      }
      ct = ct[key];
    }
    ct[keys[keys.length - 1]] = value;
    return value;
  }
  var templ;
  (function (templ) {
    var Reference = (function () {
      function Reference(view, path, gettable, settable) {
        this.gettable = gettable;
        this.settable = settable;
        this.view = view;
        this.path = path;
      }
      Reference.prototype.value = function (value) {
        if (arguments.length === 0) {
          return this.gettable ? this.view.get(this.path) : void 0;
        }
        if (this.settable) this.view.set(this.path, value);
      };
      Reference.prototype.toString = function () {
        return this.view.get(this.path) || '';
      };
      return Reference;
    })();
    templ.Reference = Reference;
    var Assignment = (function () {
      function Assignment(view, path, value) {
        this.view = view;
        this.path = path;
        this.value = value;
        this.assign = utils.bind(this.assign, this);
      }
      Assignment.prototype.assign = function (value) {
        this.view.set(this.path, this.value.call(this));
      };
      return Assignment;
    })();
    templ.Assignment = Assignment;
    var View = (function (_super) {
      __extends(View, _super);

      function View(section, template, context, options) {
        if (options === void 0) {
          options = {};
        }
        _super.call(this, section, template, context, options);
        this.context = context;
        this._callers = {};
        this._getters = {};
        if (options.parent) {
          this.parent = options.parent;
        }
      }
      View.prototype.get = function (keypath) {
        if (!this.context) return void 0;
        var pt = typeof keypath !== "string" ? keypath.join(".") : keypath;
        var v;
        try {
          var getter;
          if (!(getter = this._getters[pt])) {
            getter = this._getters[pt] = new Function("return this." + pt);
          }
          v = getter.call(this.context);
        }
        catch (e) {
          v = void 0;
        }
        v = v != void 0 ? v : this.parent ? this.parent.get(keypath) : void 0;
        debug('get value "%s": %s', keypath, v);
        return v;
      };
      View.prototype.set = function (path, value) {
        debug('set value %s on context %j', value, this.context);
        if (!this.context) return void 0;
        if (typeof path === "string") path = path.split(".");
        var ret = _set(this.context, path, value);
        this.update();
      };
      View.prototype.render = function () {
        this.update();
        var section = _super.prototype.render.call(this);
        //this.transitions.enter();
        return section;
      };
      View.prototype.ref = function (path, gettable, settable) {
        debug('reference %s, gettable: %o, settabble: %o', path, gettable, settable);
        return new Reference(this, path, gettable, settable);
      };
      View.prototype.assign = function (path, value) {
        debug('assignment %s %s', path, value);
        return new Assignment(this, path, value);
      };
      View.prototype.call = function (keypath, params) {
        var caller;
        var v;
        debug('call keypath "%s", args: "%o"', keypath, params);
        if (typeof keypath !== "string") keypath = keypath.join(".");
        if (!(caller = this._callers[keypath])) {
          var ctxPath = ["this"].concat(keypath.split("."));
          ctxPath.pop();
          caller = this._callers[keypath] = new Function("params", "return this." + keypath + ".apply(" + ctxPath.join(".") + ", params);");
        }
        try {
          v = caller.call(this.context, params);
        }
        catch (e) {
          console.error('could not call', e);
        }
        return v != void 0 ? v : this.parent ? this.parent.call(keypath, params) : void 0;
      };
      return View;
    })(vnode.View);
    templ.View = View;
  })(templ || (templ = {}));
  var attributes;
  (function (attributes) {
    var BaseAttribute = (function () {
      function BaseAttribute(ref, key, value, view) {
        this.ref = ref;
        this.key = key;
        this.value = value;
        this.view = view;
        this.initialize();
      }
      BaseAttribute.prototype.initialize = function () {};
      BaseAttribute.prototype.update = function () {};
      BaseAttribute.prototype.destroy = function () {};
      return BaseAttribute;
    })();
    attributes.BaseAttribute = BaseAttribute;
  })(attributes || (attributes = {}));
  var attributes;
  (function (attributes) {
    var _events = ['change', 'keyup', 'input'];
    var ValueAttribute = (function (_super) {
      __extends(ValueAttribute, _super);

      function ValueAttribute() {
        _super.apply(this, arguments);
      }
      ValueAttribute.prototype.initialize = function () {
        this._onInput = utils.bind(this._onInput, this, null);
        for (var _i = 0; _i < _events.length; _i++) {
          var e = _events[_i];
          this.ref.addEventListener(e, this._onInput);
        }
      };
      ValueAttribute.prototype.update = function () {
        var model = this.model = this.value;
        if (!model) return;
        if (!model || !(model instanceof templ.Reference)) {
          throw new Error("input value must be a reference. Make sure you have <~> defined");
        }
        if (model.gettable) {
          this._elementValue(this._parseValue(model.value()));
        }
      };
      ValueAttribute.prototype._parseValue = function (value) {
        if (value == null || value === "") return void 0;
        return value;
      };
      ValueAttribute.prototype._onInput = function (event) {
        clearInterval(this._autocompleteCheckInterval);
        // ignore some keys
        if (event && (!event.keyCode || !~ [27].indexOf(event.keyCode))) {
          event.stopPropagation();
        }
        var value = this._parseValue(this._elementValue());
        if (!this.model) return;
        if (String(this.model.value()) == String(value)) return;
        this.model.value(value);
      };
      ValueAttribute.prototype._elementValue = function (value) {
        var node = this.ref;
        var isCheckbox = /checkbox/.test(node.type);
        var isRadio = /radio/.test(node.type);
        var isRadioOrCheckbox = isCheckbox || isRadio;
        var hasValue = Object.prototype.hasOwnProperty.call(node, "value");
        var isInput = hasValue || /input|textarea|checkbox/.test(node.nodeName.toLowerCase());
        if (!arguments.length) {
          if (isCheckbox) {
            return Boolean(node.checked);
          }
          else if (isInput) {
            return node.value || "";
          }
          else {
            return node.innerHTML || "";
          }
        }
        if (value == null) {
          value = "";
        }
        else {
          clearInterval(this._autocompleteCheckInterval);
        }
        if (isRadioOrCheckbox) {
          if (isRadio) {
            if (String(value) === String(node.value)) {
              node.checked = true;
            }
          }
          else {
            node.checked = value;
          }
        }
        else if (String(value) !== this._elementValue()) {
          if (isInput) {
            node.value = value;
          }
          else {
            node.innerHTML = value;
          }
        }
      };
      return ValueAttribute;
    })(attributes.BaseAttribute);
    attributes.ValueAttribute = ValueAttribute;
  })(attributes || (attributes = {}));
  var attributes;
  (function (attributes) {
    var debug = utils.debug('attributes:event');
    var EventAttribute = (function (_super) {
      __extends(EventAttribute, _super);

      function EventAttribute() {
        _super.apply(this, arguments);
      }
      EventAttribute.prototype.initialize = function () {
        this._onEvent = utils.bind(this._onEvent, this);
        if (!this.event) this.event = this.key.match(/on(.+)/)[1].toLowerCase();
        debug('added event listener %s: %o', this.event, this.value);
        this.ref.addEventListener(this.event, this._onEvent);
      };
      EventAttribute.prototype._onEvent = function (e) {
        var self = this;
        var fn;
        if (this.value instanceof templ.Assignment) {
          fn = this.value.assign;
        }
        else {
          fn = this.value;
        }
        if (typeof fn !== 'function') {
          throw new Error('[event] value is not a function');
        }
        debug('fired event: %s', this.event);
        fn(e);
      };
      EventAttribute.prototype.destroy = function () {
        debug('removed event listener %s: %o', this.event, this.value);
        this.ref.removeEventListener('click', this._onEvent);
      };
      return EventAttribute;
    })(attributes.BaseAttribute);
    attributes.EventAttribute = EventAttribute;
    var KeyCodeAttribute = (function (_super) {
      __extends(KeyCodeAttribute, _super);

      function KeyCodeAttribute(ref, key, value, view) {
        this.event = "keydown";
        this.keyCodes = [];
        _super.call(this, ref, key, value, view);
      }
      KeyCodeAttribute.prototype._onEvent = function (event) {
        if (!~this.keyCodes.indexOf(event.keyCode)) {
          return;
        }
        _super.prototype._onEvent.call(this, event);
      };
      return KeyCodeAttribute;
    })(EventAttribute);
    attributes.KeyCodeAttribute = KeyCodeAttribute;
    var ClickAttribute = (function (_super) {
      __extends(ClickAttribute, _super);

      function ClickAttribute() {
        _super.apply(this, arguments);
      }
      return ClickAttribute;
    })(EventAttribute);
    attributes.ClickAttribute = ClickAttribute;
    var OnEnterAttribute = (function (_super) {
      __extends(OnEnterAttribute, _super);

      function OnEnterAttribute() {
        _super.apply(this, arguments);
        this.keyCodes = [13];
      }
      return OnEnterAttribute;
    })(KeyCodeAttribute);
    attributes.OnEnterAttribute = OnEnterAttribute;
    var OnEscapeAttribute = (function (_super) {
      __extends(OnEscapeAttribute, _super);

      function OnEscapeAttribute() {
        _super.apply(this, arguments);
        this.KeyCodes = [27];
      }
      return OnEscapeAttribute;
    })(KeyCodeAttribute);
    attributes.OnEscapeAttribute = OnEscapeAttribute;
  })(attributes || (attributes = {}));
  var attributes;
  (function (attributes) {
    attributes.value = attributes.ValueAttribute;
    attributes.onclick = attributes.ClickAttribute;
    attributes.onenter = attributes.OnEnterAttribute;
    attributes.onescape = attributes.OnEscapeAttribute;
    attributes.checked = attributes.ValueAttribute;
    attributes.style = attributes.StyleAttribute;
  })(attributes || (attributes = {}));
  var components;
  (function (components) {
    var BaseComponent = (function () {
      function BaseComponent(section, vvnode, attributes, view) {
        this.section = section;
        this.vnode = vvnode;
        this.attributes = attributes;
        this.view = view;
        this.document = view.template.options.document;
        if (vvnode.childNodes) this.childTemplate = vnode.template(vnode.fragment(vvnode.childNodes), view.template.options);
        for (var key in attributes)
        this.setAttribute(key, attributes[key]);
        this.initialize();
      }
      BaseComponent.prototype.initialize = function () {};
      BaseComponent.prototype.setAttribute = function (key, value) {
        this.attributes[key] = value;
      };
      BaseComponent.prototype.removeAttribute = function (key) {
        this.attributes[key] = void 0;
      };
      BaseComponent.prototype.destroy = function () {};
      return BaseComponent;
    })();
    components.BaseComponent = BaseComponent;
  })(components || (components = {}));
  var components;
  (function (components) {
    function _each(target, iterate) {
      if (!target) return;
      if (target.forEach) {
        // use API here since target could be an object
        target.forEach(iterate);
      }
      else {
        for (var key in target) {
          if (target.hasOwnProperty(key)) iterate(target[key], key);
        }
      }
    }
    var Repeat = (function (_super) {
      __extends(Repeat, _super);

      function Repeat() {
        _super.apply(this, arguments);
        this._children = [];
      }
      Repeat.prototype.update = function () {
        var as = this['as'];
        var each = this['each'];
        var key = this['key'] || "key";
        var n = 0;
        var self = this;
        var parent = this.view;
        var properties;
        _each(each, function (model, k) {
          var child;
          if (as) {
            properties = {};
            properties[key] = k;
            properties[as] = model;
          }
          else {
            properties = model;
          }
          // TODO - provide SAME context here for speed and stability
          if (n >= self._children.length) {
            child = self.childTemplate.view(properties, {
              parent: parent
            });
            self._children.push(child);
            self.section.appendChild(child.render(properties));
          }
          else {
            child = self._children[n];
            child.context = properties;
            child.update();
          }
          n++;
        });
        this._children.splice(n).forEach(function (child) {
          child.remove();
        });
      };
      Repeat.prototype.setAttribute = function (key, value) {
        this[key] = value;
      };
      return Repeat;
    })(components.BaseComponent);
    components.Repeat = Repeat;
  })(components || (components = {}));
  var components;
  (function (components) {
    components.repeat = components.Repeat;
  })(components || (components = {}));
  var virtualnode = {
    text: vnode.text,
    dynamic: vnode.dynamic,
    comment: vnode.comment,
    element: vnode.element,
    fragment: vnode.fragment,
    template: vnode.template
  };
  var templ;
  (function (templ) {
    templ.version = "0.0.6";
    templ.compiler = {
      compile: parser.compile,
      vnode: vnode,
      transpile: parser.transpile
    };
    templ.lib = {
      View: templ.View,
      Attribute: attributes.BaseAttribute,
      Component: components.BaseComponent,
      attributes: attributes,
      components: components
    };

    function attribute(name, attr) {
      if (typeof attr !== 'function') {
        attr = utils.extendClass(attributes.BaseAttribute, attr);
      }
      attributes[name] = attr;
    }
    templ.attribute = attribute;

    function component(name, cmp) {
      if (typeof cmp !== 'function') {
        cmp = utils.extendClass(components.BaseComponent, cmp);
      }
      components[name] = cmp;
    }
    templ.component = component;

    function modifier(name, func) {
      modifiers[name] = func;
    }
    templ.modifier = modifier;

    function debugging(enabled) {
      utils.Debug.enable(enabled);
    }
    templ.debugging = debugging;

    function compile(str, options) {
      var vn = virtualnode,
          fn = parser.compile(str);
      var vnode = fn(vn.fragment, vn.element, vn.text, vn.comment, vn.dynamic, engine.binding);
      return vn.template(vnode, utils.extend({
        document: document,
        viewClass: templ.View,
        attributes: attributes,
        components: components,
        modifiers: modifiers
      }, options || {}));
    }
    templ.compile = compile;
  })(templ || (templ = {}));
  var attributes;
  (function (attributes) {
    var StyleAttribute = (function (_super) {
      __extends(StyleAttribute, _super);

      function StyleAttribute() {
        _super.apply(this, arguments);
      }
      StyleAttribute.prototype.initialize = function () {
        this._currentStyles = {};
      };
      StyleAttribute.prototype.update = function () {
        var styles = this.value;
        if (typeof styles === "string") {
          this.ref.setAttribute("style", styles);
          return;
        }
        var newStyles = {};
        for (var name in styles) {
          var style = styles[name];
          if (style !== this._currentStyles[name]) {
            newStyles[name] = this._currentStyles[name] = style || "";
          }
        }
        for (var key in newStyles) {
          this.ref.style[key] = newStyles[key];
        }
      };
      return StyleAttribute;
    })(attributes.BaseAttribute);
    attributes.StyleAttribute = StyleAttribute;
  })(attributes || (attributes = {}));
  return templ;
}));